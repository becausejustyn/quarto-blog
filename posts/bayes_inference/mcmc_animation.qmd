---
title: "Untitled"
execute: 
  freeze: true
  eval: false
format:
  html:
    highlight: true
    code-fold: show
    code-tools: true
    highlight-style: github
---

# Animated MCMC

```{python}
import arviz as az
from IPython.display import HTML
from matplotlib.animation import FuncAnimation
import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as st


FIGSIZE = (9, 6)
az.style.use('arviz-white')

#https://colindcarroll.com/2018/11/24/animated-mcmc-with-matplotlib/
```

```{python}
class MixtureOfGaussians:
    """Two standard normal distributions, centered at +2 and -2."""
    def __init__(self):
        self.components = [st.norm(-2, 1), st.norm(2, 1)]
        self.weights = np.array([0.5, 0.5])
    
    def pdf(self, x):
        return self.weights.dot([component.pdf(x) for component in self.components])
    
    def rvs(self, size=1):
        idxs = np.random.randint(0, 2, size=size)
        result = np.empty(size)
        for idx, component in enumerate(self.components):
            spots, = np.where(idxs==idx)
            result[spots] = component.rvs(size=spots.shape[0])
        return result
```

```{python}
az.plot_kde(MixtureOfGaussians().rvs(10_000), figsize=FIGSIZE)
```

```{python}
def metropolis_sample(pdf, *, steps, step_size, init=0.):
    """Metropolis sampler with a normal proposal."""
    point = init
    samples = []
    for _ in range(steps):
        proposed = st.norm(point, step_size).rvs()
        if np.random.rand() < pdf(proposed) / pdf(point):
            point = proposed
        samples.append(point)
    return np.array(samples)
```

```{python}
seed = 0
np.random.seed(seed)
samples = metropolis_sample(MixtureOfGaussians().pdf, steps=3_000, step_size=0.4)
az.plot_trace(samples)
```

```{python}
hi, lo = samples.max(), samples.min()
x = np.linspace(lo, hi, 100)
bins = np.digitize(samples, x, right=True)

# y values
counter = np.zeros_like(bins)

# keep track of how points are already in each bin
counts = np.zeros_like(x)  
for idx, bin_ in enumerate(bins):
    counts[bin_] += 1
    counter[idx] = counts[bin_]
counter = counter / counter.max()


# Mess with plot styles here, since it is cheaper than animating
fig, ax = plt.subplots(figsize=FIGSIZE)
ax.set_ylim(0, 1)
ax.set_xlim(bins.min(), bins.max())
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)
ax.spines['left'].set_visible(False)

ax.set_xticks([])
ax.get_yaxis().set_visible(False)
cmap = plt.get_cmap('viridis')
colors = cmap(np.linspace(0, 1, bins.shape[0]))

ax.scatter(bins, counter, marker='.', facecolors=colors)
```

```{python}
fig, ax = plt.subplots(figsize=FIGSIZE)
xdata, ydata = [], []
ln = ax.scatter([], [], marker='.', animated=True)
cmap = plt.get_cmap('viridis')

def init():
    ax.set_xlim(bins.min(), bins.max())
    ax.set_ylim(0, 1)
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)

    ax.set_xticks([])
    ax.get_yaxis().set_visible(False)
    return ln,

def update(idx):
    xdata.append(bins[idx])
    ydata.append(counter[idx])
    colors = cmap(np.linspace(0, 1, len(xdata)))
    offset = (np.arange(idx + 1) - idx + 49) / 50
    y = np.maximum(ydata, offset)
    ln.set_offsets(np.array([xdata, y]).T)
    ln.set_facecolors(colors)
    return ln, 

anim = FuncAnimation(fig, update, frames=np.arange(bins.shape[0]),
                     init_func=init, blit=True, interval=20)
HTML(anim.to_html5_video())
```

```{python}
class Point:
    def __init__(self, x, y, steps=50):
        self.x = x
        self.y = y
        self.v_x = x
        self.v_y = y + 0.5
        self.step = 0
        self.steps = steps
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.step == self.steps:
            return self.x, self.y
        t = self.step / self.steps
        x = self.v_x * t
        y = -0.5 * t * t + self.v_y * t
        self.step += 1
        return x, y
```

```{python}
fig, ax = plt.subplots(figsize=FIGSIZE)
xdata, ydata = [], []
ln = ax.scatter([], [], marker='.', animated=True)
cmap = plt.get_cmap('viridis')
points = []

def init():
    ax.set_xlim(bins.min(), bins.max())
    ax.set_ylim(0, 1)
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_visible(False)

    ax.set_xticks([])
    ax.get_yaxis().set_visible(False)
    return ln,

def update(idx):
    points.append(Point(bins[idx], counter[idx]))
    colors = cmap(np.linspace(0, 1, len(points)))
    ln.set_offsets(np.array([next(p) for p in points]))
    ln.set_facecolors(colors)
    return ln, 

anim = FuncAnimation(fig, update, frames=np.arange(bins.shape[0]),
                     init_func=init, blit=True, interval=20)
HTML(anim.to_html5_video())
```
