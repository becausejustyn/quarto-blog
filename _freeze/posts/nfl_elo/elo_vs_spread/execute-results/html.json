{
  "hash": "a45ecabd21fe3a1bbb7ba8a73378d952",
  "result": {
    "markdown": "---\ntitle: \"Untitled\"\nexecute: \n  freeze: true\n  eval: false\nformat:\n  html:\n    highlight: true\n    code-fold: show\n    code-tools: true\n    highlight-style: github\n---\n\n``` {.python .cell-code}\n%matplotlib inline\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd  # at least 0.19.2 to read_csv from url\nimport seaborn as sns\nimport scipy.stats as stats\nfrom collections import OrderedDict\n# Ignore a future warning that comes from scipy.\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Seaborn setup\nsns.set_context(\"notebook\")\nsns.set_style(\"white\")\n```\n\n\n``` {.python .cell-code}\nurl = \"https://github.com/fivethirtyeight/nfl-elo-game/raw/master/data/nfl_games.csv\"\ndf = pd.read_csv(url)\nprint(df.shape)\ndf.head(5)\n```\n\n\n``` {.python .cell-code}\n# create the spread column. This is just point diff\n\ndf['spread'] = df.score1 - df.score2\nprint(\"Total teams in the dataset:\", len(df.team1.unique()))\nprint(\"Total teams after 1990:\", len(df[df.season > 1990].team1.unique()))\n```\n\n\n``` {.python .cell-code}\ndef color_coded_hist(x, **kwargs):\n    \"\"\"Color the negative and positive bins differently.\n\n    Color scheme from http://colorbrewer2.org/    \n    \"\"\"\n    hist_bins = [-75, -42, -35, -28, -21, -14, -7, 0, 7, 14, 21, 28, 35, 42, 75]\n    __, __, patches = plt.hist(x, density=True, bins=hist_bins, color=\"#f1a340\")\n    # Purple for positive spread:\n    i = next(i for i, val in enumerate(hist_bins) if val == 0)\n    for p in patches[i:]:\n        p.set_facecolor(\"#998ec3\")\n        \n\ndef best_norm(x, **kwargs):\n    \"\"\"Plot the best normal fit for the data.\"\"\"\n    mu, std = stats.norm.fit(x)\n    # Plot the PDF.\n    xmin, xmax = min(x), max(x)\n    x = np.linspace(xmin, xmax, 100)\n    p = stats.norm.pdf(x, mu, std)\n    plt.plot(x, p, 'k--', alpha = 0.6)\n```\n\n\n``` {.python .cell-code}\n# Plot all of the teams' spreads since 1990\n\ng = sns.FacetGrid(\n    df[df.season > 1990].sort_values('team1'), \n    col = \"team1\", col_wrap = 5, height = 2)\n\ng = (g\n.map(color_coded_hist, \"spread\")\n.map(best_norm, \"spread\")\n.set_titles(\"{col_name}\")\n.set_axis_labels(\"spread\", \"density\"))\n\nmsg = \"Histograms of spread (at home) since 1990. Normal approximation is dashed line.\"\nplt.suptitle(msg, y = 1.025, fontsize = 14)\n```\n\n\n``` {.python .cell-code}\n# Show some of the values\nprint(\"~ Overall ~\")\n\nprint(\n    df[\n        df.neutral == 0][\n            ['spread', 'result1']].mean())\n\nprint(\"\\n~ Past few seasons ~\")\n\nprint(\n    df[\n        (df.neutral == 0) & \n        (df.season > 2011)\n        ]\n    .groupby(\"season\")[[\"spread\", \"result1\"]]\n    .mean()\n)\n```\n\n\n``` {.python .cell-code}\n# Create a data frame with lagged rolling means and combine with the existing data\nrolling_avg = (\n    df.groupby(\"season\")[[\"spread\", \"result1\"]]\n    .mean()\n    .rolling(3, min_periods = 1)\n    .mean()\n    .shift(1)\n)\n\nrolling_avg[\"win_pct_advantage\"] = rolling_avg.result1 - 0.5\nrolling_avg[\"spread_advantage\"] = rolling_avg.spread\nrolling_avg = rolling_avg.drop(columns = [\"result1\", \"spread\"])\n```\n\n\n``` {.python .cell-code}\n# Plot everything\nsns.set_style(\"whitegrid\")\nplt.rcParams['figure.figsize'] = (14.0, 4.0)\nf, ax = plt.subplots(1, 2)\n\nsns.lineplot(x = \"season\", y = \"spread\", data = df[df.neutral == 0], ax = ax[0])\nax[0].plot(rolling_avg.index, rolling_avg.spread_advantage, 'k:')\nax[0].set_ylabel(\"home spread\")\n\nsns.lineplot(x = \"season\", y = \"result1\", data = df[df.neutral == 0], ax = ax[1])\nax[1].plot(rolling_avg.index, rolling_avg.win_pct_advantage + .5, 'k:')\nax[1].set_ylabel(\"home win percent\")\n\nplt.suptitle(\n    'Central tendency and confidence interval of spread (left), '\n    'win percent (right) by season â€” lagged moving average is dotted line',\n    fontsize = 14)\n```\n\n\n``` {.python .cell-code}\n#Convert from game to team format\n\nhome_games = df[\n    [\"date\", \"season\", \"neutral\", \"playoff\", \"team1\", \"team2\", \"result1\", \"spread\"]\n][df.season > 1990]\n\nhome_games[\"home\"] = 1\n\n# Now swap the teams for \"away\"\naway_games = home_games.rename(columns = {\"team1\": \"team2\", \"team2\": \"team1\"})\naway_games[\"home\"] = 1 - home_games.home\n\n# Remember to switch the meaning of the winning and spread columns too\naway_games[\"result1\"] = 1 - home_games.result1\naway_games[\"spread\"] = -home_games.spread\n\nby_team = pd.concat(\n    [home_games, away_games], ignore_index = True).sort_values(\n    by=[\"season\", \"team1\", \"date\"]\n)\n```\n\n\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\nfrom collections import namedtuple\n\nclass Updater(ABC):\n    def __init__(self, *hyperparameters):\n        # Form of lookup:\n        # {season: {team: [{week1 data}, {week2 data}, ... {weekN data}]}}\n        self.lookup = {}\n        self.Params = namedtuple('Params', ['date'] + list(hyperparameters))\n        \n    def iterrows(self):\n        for season, teams in self.lookup.items():\n            for team, results in teams.items():\n                for row in results:\n                    yield dict(season=season, team1=team, **row._asdict())\n        \n    def get_rows(self):\n        return [r for r in self.iterrows()]\n    \n    @abstractmethod\n    def revert_to_mean(self, season, team, keep=.3, n_obs=8):\n        pass\n    \n    @abstractmethod\n    def update(self, row):\n        pass\n```\n\n\n``` {.python .cell-code}\nclass BernoulliUpdater(Updater):\n    def __init__(self):\n        super().__init__('alpha1', 'beta1')\n        \n    def revert_to_mean(self, season, team, keep=.8, n_obs=4):\n        # default\n        alpha = beta = 1 + n_obs * .5\n        # or use existing data        \n        if season in self.lookup and team in self.lookup[season]:\n            last_entry = self.lookup[season][team].pop()\n            date, alpha0, beta0 = last_entry\n            p = alpha0 / (alpha0 + beta0)\n            alpha = 1 + n_obs * (keep * p + (1 - keep) * .5)\n            beta = 1 + n_obs * (keep * (1 - p) + (1 - keep) * .5)\n            # push back the reverted value to the list\n            self.lookup[season][team].append(self.Params(date, alpha, beta))\n        return alpha, beta\n            \n    def update(self, row):\n        if row.season not in self.lookup:\n            self.lookup[row.season] = {}\n        if row.team1 not in self.lookup[row.season]:\n            self.lookup[row.season][row.team1] = []\n            alpha, beta = self.revert_to_mean(row.season - 1, row.team1)\n        else:\n            __, alpha, beta = self.lookup[row.season][row.team1][-1]\n        # THE UPDATE STEP:\n        # a' = a + 1 if win else 0\n        # b' = b + 1 if lose\n        if row.result1 == 1:  # Won\n            alpha_beta_next = self.Params(row.date, alpha + 1, beta)\n        elif row.result1 == 0.5:  # Tie\n            alpha_beta_next = self.Params(row.date, alpha + .5, beta + .5)\n        else:  # Lost\n            alpha_beta_next = self.Params(row.date, alpha, beta + 1)\n        self.lookup[row.season][row.team1].append(alpha_beta_next)\n        return alpha, beta\n\n\nbernoulli_updater = BernoulliUpdater()\nfor i, row in by_team.iterrows():\n    bernoulli_updater.update(row)\n\nab = pd.DataFrame(bernoulli_updater.get_rows()).sort_values(['team1','season'])\ng = ab.groupby('team1')\nab = ab.assign(alpha1 = g.alpha1.shift(), beta1=g.beta1.shift())\n\nbernoulli_dataset = (\n    by_team[[c for c in by_team.columns if c != 'spread']]\n    .merge(ab, on=['season', 'date', 'team1'])\n    .reindex(columns=[\n        'season', 'date', 'home', 'neutral', 'playoff',\n        'team1', 'team2', 'result1', 'alpha1', 'beta1'])\n)\n```\n\n\n``` {.python .cell-code}\nbernoulli_dataset[(bernoulli_dataset.season == 1993) & (bernoulli_dataset.team1 == 'PHI')]\n```\n\n\n``` {.python .cell-code}\n#Convert back from \"by-team\" to \"by-game\" format\n\nb = (\n    bernoulli_dataset[['season', 'date', 'team1', 'alpha1', 'beta1']]\n    .rename(columns=dict(team1='team2', alpha1='alpha2', beta1='beta2'))\n    .merge(bernoulli_dataset, on=['season', 'date', 'team2'])\n    .join(\n        rolling_avg[['win_pct_advantage']]\n        .rename(columns={'win_pct_advantage':'home_advantage'})\n        , on='season')\n)\n\nb = (\n    b.assign(\n        pwin = \n        (b.alpha1 + b.beta2 - 1) / (b.alpha1 + b.beta1 + b.alpha2 + b.beta2 - 2)\n        # if at home and not neutral add home advantage\n        + b.home * (1 - b.neutral) * b.home_advantage\n        # if away and not neutral subtract home advantage\n        - (1 - b.home) * (1 - b.neutral) * b.home_advantage\n        ,\n        success = lambda row:  row.pwin.round() == row.result1\n    )\n    .reindex(columns=(\n        list(bernoulli_dataset.columns)\n        + ['alpha2', 'beta2', 'home_advantage', 'pwin', 'success']\n    ))\n)\n\nprint(b.success.mean())\nb.tail()\n```\n\n\n``` {.python .cell-code}\ndef plot_roc(predicted, actual, resolution=100, ax=None):\n    \"\"\"'predicted' and 'actual' are pandas Series.\"\"\"\n    ax = ax or plt.gca()\n    cutoff = np.linspace(0, 1, resolution)\n    total_pos = (actual == 1).sum()\n    total_neg = (actual != 1).sum()\n    true_positive_rate = np.fromiter(\n        map(lambda c: (actual[predicted > c] == 1).sum() / total_pos, cutoff),\n        float)\n    false_positive_rate = np.fromiter(\n        map(lambda c: (actual[predicted > c] != 1).sum() / total_neg, cutoff),\n        float)\n    ax.plot(\n        false_positive_rate, true_positive_rate,\n        linestyle='-', color=sns.color_palette()[0], linewidth=3)\n    ax.set_xlim([0,1])\n    ax.set_ylim([0,1])\n    ax.plot([0,1], [0,1], 'k:')\n    # Area under the curve\n    auc = sum((true_positive_rate[:-1] + true_positive_rate[1:]) / 2\n              * (false_positive_rate[:-1] - false_positive_rate[1:]))\n    ax.set_title('ROC curve. AUC = {:0.3f}'.format(auc), fontsize=14);\n\n\n## Start the actual plot\nplt.rcParams['figure.figsize'] = (15.0, 3.0)\nf, ax = plt.subplots(1, 3)\n\nsummary = b.groupby(['team1', 'season'], as_index=False).success.mean()\n\n# Histogram\nsns.distplot(summary.success, ax=ax[0], bins=np.linspace(0, 1, 11))\nax[0].axvline(0.5, color='k', linestyle=':')\nax[0].set_ylabel(\"frequency count\")\nax[0].set_title('Model accuracy (grouped by team, season)', fontsize=14)\n\n# Time series\nsns.lineplot(x=\"season\", y=\"success\", data=summary, ax=ax[1])\nax[1].set_ylabel(\"Model success rate\")\nax[1].set_title('Accuracy year over year (mean {:0.0%})'.format(b.success.mean()), fontsize=14)\n\n# ROC\nplot_roc(b.pwin, b.result1, resolution=100, ax=ax[2])\n```\n\n\n``` {.python .cell-code}\nclass TUpdater(Updater):\n    def __init__(self):\n        super().__init__('nu1', 'mu1', 'alpha1', 'beta1')\n        \n    def get_mean_beta(self, season):\n        mean_beta = 16**2 / 2  # Default\n        if season in self.lookup:\n            team_sets = self.lookup[season].values()\n            mean_beta = (\n                sum(ts[-1].beta1 for ts in team_sets)\n                / sum(ts[-1].nu1 for ts in team_sets))\n        return mean_beta\n        \n    def revert_to_mean(self, season, team, keep=.5, n_obs=3):\n        mean_beta = self.get_mean_beta(season - 1)  # Default\n        nu, mu, alpha, beta = n_obs, 0, n_obs / 2, mean_beta * n_obs\n        # or use existing data\n        if season in self.lookup and team in self.lookup[season]:\n            last_entry = self.lookup[season][team].pop()\n            date, nu0, mu0, alpha0, beta0 = last_entry\n            mu = keep * mu0\n            beta = nu * (keep * beta0 / nu0 + (1 - keep) * mean_beta)\n            # push back the reverted value to the list\n            self.lookup[season][team].append(self.Params(date, nu, mu, alpha, beta))\n        return nu, mu, alpha, beta\n            \n    def update(self, row):\n        if row.season not in self.lookup:\n            self.lookup[row.season] = {}\n        if row.team1 not in self.lookup[row.season]:\n            self.lookup[row.season][row.team1] = []\n            nu, mu, alpha, beta = self.revert_to_mean(row.season - 1, row.team1)\n        else:\n            __, nu, mu, alpha, beta = self.lookup[row.season][row.team1][-1]\n        # THE UPDATE STEP:\n        delta = row.spread - mu\n        nu_mu_alpha_beta_next = self.Params(\n            row.date,\n            nu + 1,                       # nu' = nu + 1\n            mu + delta / (nu + 1),        # mu' = mu + delta / (nu + 1)\n            alpha + .5,                   # alpha' = alpha + 1/2\n            beta + delta * (mu + delta / (nu + 1)) / 2\n                                          # beta' = beta + delta * mu' / 2\n        )\n        self.lookup[row.season][row.team1].append(nu_mu_alpha_beta_next)\n        return nu, mu, alpha, beta\n\n\nt_updater = TUpdater()\nfor i, row in by_team.iterrows():\n    t_updater.update(row)\n\nnmab = pd.DataFrame(t_updater.get_rows()).sort_values(['team1','season'])\ng = nmab.groupby('team1')\nnmab = nmab.assign(\n    nu1 = g.nu1.shift(),\n    mu1 = g.mu1.shift(),\n    alpha1 = g.alpha1.shift(),\n    beta1=g.beta1.shift())\n\nt_dataset = (\n    by_team[[c for c in by_team.columns if c != 'result1']]\n    .merge(nmab, on=['season', 'date', 'team1'])\n    .reindex(columns=[\n        'season', 'date', 'home', 'neutral', 'playoff',\n        'team1', 'team2', 'spread', 'nu1', 'mu1', 'alpha1', 'beta1'])\n)\n```\n\n\n``` {.python .cell-code}\nt_dataset[(t_dataset.season == 2017) & (t_dataset.team1 == 'PHI')]\n```\n\n\n``` {.python .cell-code}\nt = (\n    t_dataset[['season', 'date', 'team1', 'nu1', 'mu1', 'alpha1', 'beta1']]\n    .rename(columns=dict(\n        team1='team2', nu1='nu2', mu1='mu2', alpha1='alpha2', beta1='beta2'))\n    .merge(t_dataset, on=['season', 'date', 'team2'])\n    .join(\n        rolling_avg[['spread_advantage']]\n        .rename(columns={'spread_advantage':'home_advantage'})\n        , on='season')\n)\n\nt = (\n    t.assign(\n        pspread =\n            (t.nu1 * t.mu1 - t.nu2 * t.mu2) / (t.nu1 + t.nu2)\n            # if at home and not neutral add home advantage\n            + t.home * (1 - t.neutral) * t.home_advantage\n            # if away and not neutral subtract home advantage\n            - (1 - t.home) * (1 - t.neutral) * t.home_advantage\n        ,\n        betaprime =\n            t.beta1 + t.beta2\n            + (t.nu1 * t.nu2) / (t.nu1 + t.nu2)\n            * (t.mu1 + t.mu2)**2 / 2\n        ,\n        pwin = (\n            lambda row: 1 - stats.t.cdf(\n                0,\n                row.nu1 + row.nu2,\n                loc=row.pspread,\n                scale=(\n                    row.betaprime\n                    * (row.nu1 + row.nu2 + 1)\n                    / (row.nu1 + row.nu2) / (row.alpha1 + row.alpha2)\n                )))\n        ,\n        success = lambda row: row.pwin.round() == (row.spread > 0)\n    )\n    .reindex(columns=(\n        list(t_dataset.columns)\n        + ['nu2', 'mu2', 'alpha2', 'beta2', 'home_advantage', 'pspread', 'pwin', 'success']\n    ))\n)\n\nprint(t.success.mean())\nprint(t.shape)\nt.tail()\n```\n\n\n``` {.python .cell-code}\n# use toggle\nss_res = ((t.spread - t.pspread)**2).sum()\nss_tot = ((t.spread - t.spread.mean())**2).sum()\nr_squared = 1 -  ss_res/ ss_tot\nsns.jointplot(\"spread\", \"pspread\", data=t, kind=\"hex\", space=0, color=\"b\", ratio=4)\ntitle = \"Actual spread vs. mean of  distribution. R squared= {:0.0%}\".format(r_squared)\nplt.suptitle(title, x=.45, y=1.01, fontsize=14)\n```\n\n\n``` {.python .cell-code}\n# use toggle\nplt.rcParams['figure.figsize'] = (15.0, 3.0)\nf, ax = plt.subplots(1, 3)\n\nsummary = t.groupby(['team1', 'season'], as_index=False).success.mean()\n\n# Histogram\nsns.distplot(summary.success, ax=ax[0], bins=np.linspace(0, 1, 11))\nax[0].axvline(0.5, color='k', linestyle=':')\nax[0].set_ylabel(\"frequency count\")\nax[0].set_title('Model accuracy (grouped by team, season)', fontsize=14)\n\n# Time series\nsns.lineplot(x=\"season\", y=\"success\", data=summary, ax=ax[1])\nax[1].set_ylabel(\"Model success rate\")\nax[1].set_title('Accuracy year over year (mean {:0.0%})'.format(t.success.mean()), fontsize=14)\n\n# ROC\nplot_roc(t.pwin, t.spread > 0, resolution=100, ax=ax[2])\n```\n\n\n",
    "supporting": [
      "elo_vs_spread_files"
    ],
    "filters": [],
    "includes": {}
  }
}