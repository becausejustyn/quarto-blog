{
  "hash": "f24d4d7905f119632b915074e45e8ed7",
  "result": {
    "markdown": "---\ntitle: \"Untitled\"\nexecute: \n  freeze: true\n  eval: false\nformat:\n  html:\n    highlight: true\n    code-fold: show\n    code-tools: true\n    highlight-style: github\n---\n\n``` {.python .cell-code}\n#https://blog.collegefootballdata.com/talking-tech-elo-ratings/\nimport cfbd\nimport datetime\nimport numpy as np\nimport pandas as pd\n```\n\n\n``` {.python .cell-code}\n# configure API key\nconfiguration = cfbd.Configuration()\nconfiguration.api_key['Authorization'] = '+TdVQcvhNBRAN948z/lsmZN4ETE9sQ60VyQtobVZ+ARur3G1brcO6FLqhoXAYZw1'\nconfiguration.api_key_prefix['Authorization'] = 'Bearer'\n\n# instantiate a games API instance\napi_config = cfbd.ApiClient(configuration)\ngames_api = cfbd.GamesApi(cfbd.ApiClient(configuration))\n```\n\n\n``` {.python .cell-code}\n#logistic curve function\n\ndef get_expected_score(team_a, team_b):\n    exp = (team_b - team_a) / 400\n    return(1 / (1 + 10**exp))\n\n#team_a_new_elo = team_a_old_elo + K (score for team A - expected score for team A)\n```\n\n\n``` {.python .cell-code}\nprint(get_expected_score(1500, 1500))\nprint(get_expected_score(1500, 1400))\nprint(get_expected_score(1750, 1500))\nprint(get_expected_score(2000, 1500))\n```\n\n\n``` {.python .cell-code}\n#Making adjustments to Elo score based on the outcome of a game. \n# takes home team Elo rating, away team Elo rating, and final scoring margin as parameters and returns the new Elo ratings for the participants. \n\ndef get_new_elos(home_rating, away_rating, margin):\n    k = 25\n\n    # score of 0.5 for a tie\n    home_score = 0.5\n    if margin > 0:\n        # score of 1 for a win\n        home_score = 1\n    elif margin < 0:\n        #score of 0 for a loss\n        home_score = 0\n\n    # get expected home score\n    expected_home_score = get_expected_score(home_rating, away_rating)\n    # multiply difference of actual and expected score by k value and adjust home rating\n    new_home_score = home_rating + k * (home_score - expected_home_score)\n\n    # repeat these steps for the away team\n    # away score is inverse of home score\n    away_score = 1 - home_score\n    expected_away_score = get_expected_score(away_rating, home_rating)\n    new_away_score = away_rating + k * (away_score - expected_away_score)\n\n    # return a tuple\n    return(round(new_home_score), round(new_away_score))\n```\n\n\n``` {.python .cell-code}\n# Again, we're merely finding the difference in actual and expected scores for each team, multiplying them by our predefined K factor of 25, and adding that adjustment to the pregame Elo scores. \n# Finally, we returned a tuple of two values, the first being the new Elo rating for the home team and the second being that of the away team. \n# I should probably also note that the margin value refers to the difference in home and away points (i.e. a positive value is a home win while a negative value is an away win)\n\n# takes a data string and converts it to a datetime object for sorting\ndef date_sort(game):\n    game_date = datetime.datetime.strptime(game['start_date'], \"%Y-%m-%dT%H:%M:%S.000Z\")\n    return(game_date)\n\n# returns an elo rating\ndef elo_sort(team):\n    return(team['elo'])\n```\n\n\n``` {.python .cell-code}\ngames = []\n\nfor year in range(2010, 2022):\n    response = games_api.get_games(year = year)\n    games = [*games, *response]\n\ngames = [dict(\n            start_date = g.start_date,\n            home_team = g.home_team,\n            home_conference = g.home_conference,\n            home_points = g.home_points,\n            away_team = g.away_team,\n            away_conference = g.away_conference,\n            away_points = g.away_points\n            ) for g in games if g.home_points is not None and g.away_points is not None]\n\ngames.sort(key = date_sort)\n```\n\n\n``` {.python .cell-code}\n# We can now loop through each game to calculate current Elo ratings for each team. \n# We will also be tracking pregame and postgame Elo ratings for each game for each team so that we can track team trends over time as well as look at how game outcomes affect team ratings.\n\n# dict object to hold current Elo rating for each team\nteams = dict()\n\n# loop through games in order\nfor game in games:\n\n    # get current rating for home team\n    if game['home_team'] in teams:\n        home_elo = teams[game['home_team']]\n    elif game['home_conference'] is not None:\n        # if no rating, set initial rating to 1500 for FBS teams\n        home_elo = 1500\n    else:\n        # otherwise, set initial rating to 1200 for non-FBS teams\n        home_elo = 1200\n\n    # get current rating for away team\n    if game['away_team'] in teams:\n        away_elo = teams[game['away_team']]\n    elif game['away_conference'] is not None:\n        # if no rating, set initial rating to 1500 for FBS teams\n        away_elo = 1500\n    else:\n        # otherwise, set initial rating to 1200 for non-FBS teams\n        away_elo = 1200\n\n    # calculate score margin from game\n    margin = game['home_points'] - game['away_points']\n\n    # get new elo ratings\n    new_elos = get_new_elos(home_elo, away_elo, margin)\n\n    # set pregame elos on game dict\n    game['pregame_home_elo'] = home_elo\n    game['pregame_away_elo'] = away_elo\n\n    # set postgame elos on game dict\n    game['postgame_home_elo'] = new_elos[0]\n    game['postgame_away_elo'] = new_elos[1]\n\n    # set current elo values in teams dict\n    teams[game['home_team']] = new_elos[0]\n    teams[game['away_team']] = new_elos[1]\n```\n\n\n``` {.python .cell-code}\n# For non-FBS teams, we'll set an initial rating of 1200.\n\n#convert our team dict (which holds the current rating for each team) into a list ordered by rating from highest to lowest\n\nend_elos = [dict(team = key, elo = teams[key]) for key in teams]\nend_elos.sort(key = elo_sort, reverse = True)\n```\n\n\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# This is the styling I use. Check out other themes here: https://matplotlib.org/3.2.1/gallery/style_sheets/style_sheets_reference.html\nplt.style.use('fivethirtyeight')\n\n# Graph sizing\nplt.rcParams[\"figure.figsize\"] = [20,10]\n```\n\n\n``` {.python .cell-code}\ndef generate_chart(team):\n    team_games = []\n    for game in games:\n        if game['home_team'] == team:\n            team_games.append(dict(start_date = game['start_date'], elo = game['postgame_home_elo']))\n\n        if game['away_team'] == team:\n            team_games.append(dict(start_date = game['start_date'], elo = game['postgame_away_elo']))\n\n    df = pd.DataFrame.from_records(team_games)\n\n    fig, ax = plt.subplots()\n    ax.plot(df.index, df['elo'])\n\n    ax.set(xlabel = 'Game No.', ylabel = 'Elo Rating',\n           title = \"Historical Elo Rating - {0}\".format(team))\n\n    plt.show()\n```\n\n\n``` {.python .cell-code}\ngenerate_chart('Michigan')\n```\n\n\n",
    "supporting": [
      "college_elo_python_files"
    ],
    "filters": [],
    "includes": {}
  }
}