{
  "hash": "015d1a1ab3854dcb499f4d9cf9610458",
  "result": {
    "markdown": "---\ntitle: \"Untitled\"\nformat: html\nexecute: \n  eval: false\n---\n\n# Animated MCMC\n\n``` {.python .cell-code}\nimport arviz as az\nfrom IPython.display import HTML\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.stats as st\n\n\nFIGSIZE = (9, 6)\naz.style.use('arviz-white')\n\n#https://colindcarroll.com/2018/11/24/animated-mcmc-with-matplotlib/\n```\n\n\n``` {.python .cell-code}\nclass MixtureOfGaussians:\n    \"\"\"Two standard normal distributions, centered at +2 and -2.\"\"\"\n    def __init__(self):\n        self.components = [st.norm(-2, 1), st.norm(2, 1)]\n        self.weights = np.array([0.5, 0.5])\n    \n    def pdf(self, x):\n        return self.weights.dot([component.pdf(x) for component in self.components])\n    \n    def rvs(self, size=1):\n        idxs = np.random.randint(0, 2, size=size)\n        result = np.empty(size)\n        for idx, component in enumerate(self.components):\n            spots, = np.where(idxs==idx)\n            result[spots] = component.rvs(size=spots.shape[0])\n        return result\n```\n\n\n``` {.python .cell-code}\naz.plot_kde(MixtureOfGaussians().rvs(10_000), figsize=FIGSIZE)\n```\n\n\n``` {.python .cell-code}\ndef metropolis_sample(pdf, *, steps, step_size, init=0.):\n    \"\"\"Metropolis sampler with a normal proposal.\"\"\"\n    point = init\n    samples = []\n    for _ in range(steps):\n        proposed = st.norm(point, step_size).rvs()\n        if np.random.rand() < pdf(proposed) / pdf(point):\n            point = proposed\n        samples.append(point)\n    return np.array(samples)\n```\n\n\n``` {.python .cell-code}\nseed = 0\nnp.random.seed(seed)\nsamples = metropolis_sample(MixtureOfGaussians().pdf, steps=3_000, step_size=0.4)\naz.plot_trace(samples)\n```\n\n\n``` {.python .cell-code}\nhi, lo = samples.max(), samples.min()\nx = np.linspace(lo, hi, 100)\nbins = np.digitize(samples, x, right=True)\n\n# y values\ncounter = np.zeros_like(bins)\n\n# keep track of how points are already in each bin\ncounts = np.zeros_like(x)  \nfor idx, bin_ in enumerate(bins):\n    counts[bin_] += 1\n    counter[idx] = counts[bin_]\ncounter = counter / counter.max()\n\n\n# Mess with plot styles here, since it is cheaper than animating\nfig, ax = plt.subplots(figsize=FIGSIZE)\nax.set_ylim(0, 1)\nax.set_xlim(bins.min(), bins.max())\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.spines['left'].set_visible(False)\n\nax.set_xticks([])\nax.get_yaxis().set_visible(False)\ncmap = plt.get_cmap('viridis')\ncolors = cmap(np.linspace(0, 1, bins.shape[0]))\n\nax.scatter(bins, counter, marker='.', facecolors=colors)\n```\n\n\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=FIGSIZE)\nxdata, ydata = [], []\nln = ax.scatter([], [], marker='.', animated=True)\ncmap = plt.get_cmap('viridis')\n\ndef init():\n    ax.set_xlim(bins.min(), bins.max())\n    ax.set_ylim(0, 1)\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n\n    ax.set_xticks([])\n    ax.get_yaxis().set_visible(False)\n    return ln,\n\ndef update(idx):\n    xdata.append(bins[idx])\n    ydata.append(counter[idx])\n    colors = cmap(np.linspace(0, 1, len(xdata)))\n    offset = (np.arange(idx + 1) - idx + 49) / 50\n    y = np.maximum(ydata, offset)\n    ln.set_offsets(np.array([xdata, y]).T)\n    ln.set_facecolors(colors)\n    return ln, \n\nanim = FuncAnimation(fig, update, frames=np.arange(bins.shape[0]),\n                     init_func=init, blit=True, interval=20)\nHTML(anim.to_html5_video())\n```\n\n\n``` {.python .cell-code}\nclass Point:\n    def __init__(self, x, y, steps=50):\n        self.x = x\n        self.y = y\n        self.v_x = x\n        self.v_y = y + 0.5\n        self.step = 0\n        self.steps = steps\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.step == self.steps:\n            return self.x, self.y\n        t = self.step / self.steps\n        x = self.v_x * t\n        y = -0.5 * t * t + self.v_y * t\n        self.step += 1\n        return x, y\n```\n\n\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=FIGSIZE)\nxdata, ydata = [], []\nln = ax.scatter([], [], marker='.', animated=True)\ncmap = plt.get_cmap('viridis')\npoints = []\n\ndef init():\n    ax.set_xlim(bins.min(), bins.max())\n    ax.set_ylim(0, 1)\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n\n    ax.set_xticks([])\n    ax.get_yaxis().set_visible(False)\n    return ln,\n\ndef update(idx):\n    points.append(Point(bins[idx], counter[idx]))\n    colors = cmap(np.linspace(0, 1, len(points)))\n    ln.set_offsets(np.array([next(p) for p in points]))\n    ln.set_facecolors(colors)\n    return ln, \n\nanim = FuncAnimation(fig, update, frames=np.arange(bins.shape[0]),\n                     init_func=init, blit=True, interval=20)\nHTML(anim.to_html5_video())\n```\n\n\n",
    "supporting": [
      "mcmc_animation_files"
    ],
    "filters": [],
    "includes": {}
  }
}