{
  "hash": "31da49f2082fed038a437b9b6d9b6c4f",
  "result": {
    "markdown": "---\ntitle: \"Untitled\"\nexecute: \n  freeze: true\n  eval: true\nformat:\n  html:\n    highlight: true\n    code-fold: show\n    code-tools: true\n    highlight-style: github\n---\n\n\n# Gambling Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(glue)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmoney_line <- function(fav, underdog) {\n    \n  fav_odds = (fav * -1)\n  prob1 = fav_odds / (fav_odds + underdog)\n  prob2 = underdog / (fav_odds + underdog)\n  fav_prob = prob1 %>% round(3)\n  underdog_prob = prob2 %>% round(3)\n  \n  return(glue::glue(\"Favourite odds: {fav_prob}\\n Underdog odds:{underdog_prob}\"))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmoney_line(-130, 110)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFavourite odds: 0.542\nUnderdog odds:0.458\n```\n:::\n:::\n\n\nThe problem with the above function is that it requires the input values to be in a specific order. If you want a more general approach that does not specify the order of the two values, you could do something like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoney_line2 <- function(arg1, arg2) {\n  \n  fav = sort(c(arg1, arg2))[1]\n  underdog = sort(c(arg1, arg2))[2]\n    \n  fav_val = fav * -1\n  \n  fav_prob = fav_val / (fav_val + underdog)\n  \n  return(fav_prob %>% round(3))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmoney_line2(-425, 351)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.548\n```\n:::\n\n```{.r .cell-code}\nmoney_line2(351, -425)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.548\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlogit <- function(p) { \n  out <- log(p/(1 - p))\n  return(out)\n}\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}