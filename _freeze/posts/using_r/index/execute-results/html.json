{
  "hash": "8426e53282d488fda4671db6a661534c",
  "result": {
    "markdown": "---\ntitle: \"Trying R\"\nformat:\n  html:\n    code-fold: show\n    code-tools: true\n    highlight-style: github\n    #code-tools: true\n---\n\n\nUni starts back up soon so I thought it would be a good idea to brush up on my `python`. I have avoided using `python` since `R` is much more user friendly between `dplyr` and `ggplot2`. Now that RStudio has `python` computability via `reticulate` there is not really a good reason to completely avoid `python`. I think it is always good practice to get more comfortable with different languages, because sometimes you will need to do a task that is only available using a specific tool. Similarly, there are times when a group project works best when everybody is able to use a similar language.\n\nAs tempting as it might be to do all my data wrangling via `tidyverse`, I have been practising using pandas. This post was entirely written in RStudio, however, the `python` code will run in a notebook alternative such as Jupyter or VS Code. \n\n### Installing Packages \n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"purrr\")\n\n#or simply\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n!pip3 install seaborn\n!pip3 install numpy\n!pip3 install pandas\n\n#You can also install these packages in the terminal \npip3 install seaborn\npip3 install numpy\npip3 install pandas\n```\n:::\n\n:::\n\nLearning `python` was overwhelming because you use the terminal much more often than you need to when using `R`. Over time, I have began to appreciate using a virtual environment because you can easily run multiple versions of `python`, which makes it more practical when you are using a package that requires an older version. \n\n### Importing Data, Loading Libraries\n\nI have hidden the output of the code, however, you can view it by clicking the dropdown menu. I did this primarily for myself so it was easier to scroll down, but I think it is also more practical since the output is not necessarily the focus of this post.\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\ndf <- diamonds\n\ndf %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport seaborn as sns\nimport numpy as np\nimport pandas as pd\nsns.set_style('white')\n\ndf = sns.load_dataset('diamonds')\n\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   carat      cut color clarity  depth  table  price     x     y     z\n0   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43\n1   0.21  Premium     E     SI1   59.8   61.0    326  3.89  3.84  2.31\n2   0.23     Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31\n3   0.29  Premium     I     VS2   62.4   58.0    334  4.20  4.23  2.63\n4   0.31     Good     J     SI2   63.3   58.0    335  4.34  4.35  2.75\n```\n:::\n:::\n\n\n:::\n\n### Example of Functions\n\n::: {.panel-tabset}\n\n### Verbs\n\n|                            dplyr |                           pandas |\n|---------------------------------:|---------------------------------:|\n|         `filter()` and `slice()` |  `query()` and `loc[]`, `iloc[]` |\n|                      `arrange()` | `sort_values` and `sort_index()` |\n|        `select()` and `rename()` |     `__getitem__` and `rename()` |\n|                       `select()` |                       `filter()` |\n|                     `distinct()` |              `drop_duplicates()` |\n|                       `mutate()` |                         `assign` |\n|                    `summarise()` |                            `agg` |\n|                     `group_by()` |                      `groupby()` |\n| `sample_n()` and `sample_frac()` |                         `sample` |\n|                            `%>%` |                       `pipe[^1]` |\n\n### Example\n\n|                                           dplyr |                                       pandas |\n|------------------------------------------------:|---------------------------------------------:|\n|                 `filter(df, col == 'val')`      |                   `df.query('col == \"val\"')` |\n|                         `arrange(df, col)`      |                      `df.sort_values('val')` |\n|           `rename(df, new_name = old_name)`     | `df.rename(columns = {old_name = new_name})` |\n|                           `select(df, col)`     |                              `df.loc['val']` |\n|           `distinct(df, col, .keep_all = TRUE)` |              `df[['val']].drop_duplicates()` |\n|                  `mutate(new_var = col - col2)` |      `df.assign(new_var = df.col - df.col2)` |\n| `summarise(mean = mean(col2), n = count(col1))` |  `df.agg({\"col1\": \"count\", \"col2\", \"mean\"})` |\n|                             `group_by(df, col)` |                          `df.groupby('col')` |\n|                                           `%>%` |                                   `pipe[^1]` |\n\n:::\n\n[^1]: To the best of my knowledge, you can still pipe without using the function, however, I have not explored it that much.\n\nOne of the confusing things are first is that there are many similar functions under different names. I personally find it easier to remember them by the way I write my code. For example, by only using `<-` as an assignment operator in `R`, I find it easier to treat the two languages differently. \n\n### Selecting Columns\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#select(df, color, cut)\n\ndf %>%\n  select(color, cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 × 2\n   color cut      \n   <ord> <ord>    \n 1 E     Ideal    \n 2 E     Premium  \n 3 E     Good     \n 4 I     Premium  \n 5 J     Good     \n 6 J     Very Good\n 7 I     Very Good\n 8 H     Very Good\n 9 E     Fair     \n10 H     Very Good\n# … with 53,930 more rows\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf.filter(['color', 'cut'])\n\n#or\n#df[['color', 'cut']]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      color        cut\n0         E      Ideal\n1         E    Premium\n2         E       Good\n3         I    Premium\n4         J       Good\n...     ...        ...\n53935     D      Ideal\n53936     D       Good\n53937     D  Very Good\n53938     H    Premium\n53939     D      Ideal\n\n[53940 rows x 2 columns]\n```\n:::\n:::\n\n\n:::\n\n### If we want to select a range of columns\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(df, x:z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 × 3\n       x     y     z\n   <dbl> <dbl> <dbl>\n 1  3.95  3.98  2.43\n 2  3.89  3.84  2.31\n 3  4.05  4.07  2.31\n 4  4.2   4.23  2.63\n 5  4.34  4.35  2.75\n 6  3.94  3.96  2.48\n 7  3.95  3.98  2.47\n 8  4.07  4.11  2.53\n 9  3.87  3.78  2.49\n10  4     4.05  2.39\n# … with 53,930 more rows\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf.loc[:, 'x':'z']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          x     y     z\n0      3.95  3.98  2.43\n1      3.89  3.84  2.31\n2      4.05  4.07  2.31\n3      4.20  4.23  2.63\n4      4.34  4.35  2.75\n...     ...   ...   ...\n53935  5.75  5.76  3.50\n53936  5.69  5.75  3.61\n53937  5.66  5.68  3.56\n53938  6.15  6.12  3.74\n53939  5.83  5.87  3.64\n\n[53940 rows x 3 columns]\n```\n:::\n:::\n\n\n:::\n\n### If we want to pipe it \n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  select(color, cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 × 2\n   color cut      \n   <ord> <ord>    \n 1 E     Ideal    \n 2 E     Premium  \n 3 E     Good     \n 4 I     Premium  \n 5 J     Good     \n 6 J     Very Good\n 7 I     Very Good\n 8 H     Very Good\n 9 E     Fair     \n10 H     Very Good\n# … with 53,930 more rows\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(df\n.filter(['color', 'cut'])\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      color        cut\n0         E      Ideal\n1         E    Premium\n2         E       Good\n3         I    Premium\n4         J       Good\n...     ...        ...\n53935     D      Ideal\n53936     D       Good\n53937     D  Very Good\n53938     H    Premium\n53939     D      Ideal\n\n[53940 rows x 2 columns]\n```\n:::\n:::\n\n\n:::\n\n### If we want to drop a certain column\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(df, -(x:z))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 × 7\n   carat cut       color clarity depth table price\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int>\n 1  0.23 Ideal     E     SI2      61.5    55   326\n 2  0.21 Premium   E     SI1      59.8    61   326\n 3  0.23 Good      E     VS1      56.9    65   327\n 4  0.29 Premium   I     VS2      62.4    58   334\n 5  0.31 Good      J     SI2      63.3    58   335\n 6  0.24 Very Good J     VVS2     62.8    57   336\n 7  0.24 Very Good I     VVS1     62.3    57   336\n 8  0.26 Very Good H     SI1      61.9    55   337\n 9  0.22 Fair      E     VS2      65.1    61   337\n10  0.23 Very Good H     VS1      59.4    61   338\n# … with 53,930 more rows\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(df\n.drop(['x', 'y', 'z'], axis = 1)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       carat        cut color clarity  depth  table  price\n0       0.23      Ideal     E     SI2   61.5   55.0    326\n1       0.21    Premium     E     SI1   59.8   61.0    326\n2       0.23       Good     E     VS1   56.9   65.0    327\n3       0.29    Premium     I     VS2   62.4   58.0    334\n4       0.31       Good     J     SI2   63.3   58.0    335\n...      ...        ...   ...     ...    ...    ...    ...\n53935   0.72      Ideal     D     SI1   60.8   57.0   2757\n53936   0.72       Good     D     SI1   63.1   55.0   2757\n53937   0.70  Very Good     D     SI1   62.8   60.0   2757\n53938   0.86    Premium     H     SI2   61.0   58.0   2757\n53939   0.75      Ideal     D     SI2   62.2   55.0   2757\n\n[53940 rows x 7 columns]\n```\n:::\n:::\n\n\n:::\n\n### filtering on one condition\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(df, color == 'E')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9,797 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n 5  0.2  Premium   E     SI2      60.2    62   345  3.79  3.75  2.27\n 6  0.32 Premium   E     I1       60.9    58   345  4.38  4.42  2.68\n 7  0.23 Very Good E     VS2      63.8    55   352  3.85  3.92  2.48\n 8  0.23 Very Good E     VS1      60.7    59   402  3.97  4.01  2.42\n 9  0.23 Very Good E     VS1      59.5    58   402  4.01  4.06  2.4 \n10  0.23 Good      E     VS1      64.1    59   402  3.83  3.85  2.46\n# … with 9,787 more rows\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(df\n.query(\"color == 'E'\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       carat        cut color clarity  depth  table  price     x     y     z\n0       0.23      Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43\n1       0.21    Premium     E     SI1   59.8   61.0    326  3.89  3.84  2.31\n2       0.23       Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31\n8       0.22       Fair     E     VS2   65.1   61.0    337  3.87  3.78  2.49\n14      0.20    Premium     E     SI2   60.2   62.0    345  3.79  3.75  2.27\n...      ...        ...   ...     ...    ...    ...    ...   ...   ...   ...\n53926   0.71      Ideal     E     SI1   61.9   56.0   2756  5.71  5.73  3.54\n53928   0.79    Premium     E     SI2   61.4   58.0   2756  6.03  5.96  3.68\n53930   0.71    Premium     E     SI1   60.5   55.0   2756  5.79  5.74  3.49\n53932   0.70  Very Good     E     VS2   60.5   59.0   2757  5.71  5.76  3.47\n53933   0.70  Very Good     E     VS2   61.2   59.0   2757  5.69  5.72  3.49\n\n[9797 rows x 10 columns]\n```\n:::\n:::\n\n\n:::\n\n### If we want multiple conditions\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(df, color == 'E', cut == 'Good')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 933 × 10\n   carat cut   color clarity depth table price     x     y     z\n   <dbl> <ord> <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Good  E     VS1      56.9    65   327  4.05  4.07  2.31\n 2  0.23 Good  E     VS1      64.1    59   402  3.83  3.85  2.46\n 3  0.26 Good  E     VVS1     57.9    60   554  4.22  4.25  2.45\n 4  0.7  Good  E     VS2      57.5    58  2759  5.85  5.9   3.38\n 5  0.71 Good  E     VS2      59.2    61  2772  5.8   5.88  3.46\n 6  0.7  Good  E     VS2      64.1    59  2777  5.64  5.59  3.6 \n 7  0.7  Good  E     VS1      57.2    62  2782  5.81  5.77  3.31\n 8  0.76 Good  E     SI1      63.7    54  2789  5.76  5.85  3.7 \n 9  0.7  Good  E     VS2      64.1    55  2793  5.6   5.66  3.61\n10  0.73 Good  E     SI1      63.2    58  2796  5.7   5.76  3.62\n# … with 923 more rows\n```\n:::\n\n```{.r .cell-code}\n#or\n#filter(df, color == 'E' & cut == 'Good')\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(df\n.query('color == \"E\" & cut == \"Good\"')\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       carat   cut color clarity  depth  table  price     x     y     z\n2       0.23  Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31\n36      0.23  Good     E     VS1   64.1   59.0    402  3.83  3.85  2.46\n84      0.26  Good     E    VVS1   57.9   60.0    554  4.22  4.25  2.45\n95      0.70  Good     E     VS2   57.5   58.0   2759  5.85  5.90  3.38\n169     0.71  Good     E     VS2   59.2   61.0   2772  5.80  5.88  3.46\n...      ...   ...   ...     ...    ...    ...    ...   ...   ...   ...\n53695   0.75  Good     E     VS2   59.7   65.0   2717  5.85  5.80  3.48\n53739   0.73  Good     E     VS2   63.3   60.0   2723  5.67  5.73  3.61\n53741   0.78  Good     E     SI1   57.9   62.0   2723  6.06  6.03  3.50\n53785   0.89  Good     E     SI2   64.3   65.0   2728  6.00  5.95  3.84\n53890   0.73  Good     E     SI1   57.9   55.0   2749  6.00  5.96  3.46\n\n[933 rows x 10 columns]\n```\n:::\n:::\n\n\n:::\n\n### If we want multiple conditions in one column\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n    filter(color %in% c('E', 'J'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12,605 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 5  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 6  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n 7  0.3  Good      J     SI1      64      55   339  4.25  4.28  2.73\n 8  0.23 Ideal     J     VS1      62.8    56   340  3.93  3.9   2.46\n 9  0.31 Ideal     J     SI2      62.2    54   344  4.35  4.37  2.71\n10  0.2  Premium   E     SI2      60.2    62   345  3.79  3.75  2.27\n# … with 12,595 more rows\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(df\n.query('color in [\"E\", \"J\"]')\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       carat        cut color clarity  depth  table  price     x     y     z\n0       0.23      Ideal     E     SI2   61.5   55.0    326  3.95  3.98  2.43\n1       0.21    Premium     E     SI1   59.8   61.0    326  3.89  3.84  2.31\n2       0.23       Good     E     VS1   56.9   65.0    327  4.05  4.07  2.31\n4       0.31       Good     J     SI2   63.3   58.0    335  4.34  4.35  2.75\n5       0.24  Very Good     J    VVS2   62.8   57.0    336  3.94  3.96  2.48\n...      ...        ...   ...     ...    ...    ...    ...   ...   ...   ...\n53926   0.71      Ideal     E     SI1   61.9   56.0   2756  5.71  5.73  3.54\n53928   0.79    Premium     E     SI2   61.4   58.0   2756  6.03  5.96  3.68\n53930   0.71    Premium     E     SI1   60.5   55.0   2756  5.79  5.74  3.49\n53932   0.70  Very Good     E     VS2   60.5   59.0   2757  5.71  5.76  3.47\n53933   0.70  Very Good     E     VS2   61.2   59.0   2757  5.69  5.72  3.49\n\n[12605 rows x 10 columns]\n```\n:::\n:::\n\n\n:::\n\n### Count Missing Values\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sum of missing values in each column\ndf %>% \n  summarise(across(everything(), ~sum(is.na(.))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 10\n  carat   cut color clarity depth table price     x     y     z\n  <int> <int> <int>   <int> <int> <int> <int> <int> <int> <int>\n1     0     0     0       0     0     0     0     0     0     0\n```\n:::\n\n```{.r .cell-code}\n#purrr::map_df(df, ~sum(is.na(.)))\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf.isna().sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncarat      0\ncut        0\ncolor      0\nclarity    0\ndepth      0\ntable      0\nprice      0\nx          0\ny          0\nz          0\ndtype: int64\n```\n:::\n:::\n\n\n:::\n\n### Count Unique Values in Each Column \n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# getting the count of unique values in each column \ndf %>% \n  summarise(across(everything(), n_distinct))\n\n#can also map across for the same result\npurrr::map_df(df, ~sum(n_distinct(.)))\n\n# if you just want numerical columns\ndf %>% \n  summarise(across(where(is.numeric), n_distinct))\n```\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf.nunique()\n\n# If you want unique values in numeric columns\ndf.select_dtypes(include = np.number).nunique()\n#or\ndf.select_dtypes('number').nunique()\n\n# If you just want the column names of numeric type\ndf.select_dtypes('number').columns\n# If you want them as a list\ndf.select_dtypes(include = np.number).columns.tolist()\n\n# count and unique values\ndf.agg(['count', 'size', 'nunique'])\n\n#for the proportions\ndf.select_dtypes(include = np.number).value_counts(normalize = True)\n#or\ndf.select_dtypes('number').value_counts(normalize = True)\n```\n:::\n\n\n:::\n\n### Complex Pipings\n\n::: {.panel-tabset}\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  select(starts_with('c')) %>%\n  filter(cut %in% c('Ideal', 'Premium')) %>%\n  group_by(cut, color, clarity) %>%\n  summarise(\n    avgcarat = mean(carat, na.rm=TRUE),\n    n = n()\n    ) %>%\n  arrange(-avgcarat) %>% #desc(avgcarat) also works\n  head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'cut', 'color'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n# Groups:   cut, color [4]\n  cut     color clarity avgcarat     n\n  <ord>   <ord> <ord>      <dbl> <int>\n1 Ideal   J     I1          1.99     2\n2 Premium I     I1          1.61    24\n3 Premium J     I1          1.58    13\n4 Premium J     SI2         1.55   161\n5 Ideal   H     I1          1.48    38\n6 Premium I     SI2         1.42   312\n```\n:::\n:::\n\n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(df\n .filter(regex = '^c')\n .query('cut in [\"Ideal\", \"Premium\"]')\n .groupby(['cut', 'color', 'clarity'])\n .agg(['mean', 'size'])\n .sort_values(by = ('carat', 'mean'), ascending = False)\n .head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          carat     \n                           mean size\ncut     color clarity               \nIdeal   J     I1       1.990000    2\nPremium I     I1       1.605833   24\n        J     I1       1.578462   13\n              SI2      1.554534  161\nIdeal   H     I1       1.475526   38\n```\n:::\n:::\n\n\n:::\n\n### More Examples\n\n#### Transforming\n\n| R                                | pandas                                                |\n|----------------------------------|-------------------------------------------------------|\n| `select(df, col_one = col1)`     | `df.rename(columns = {'col1': 'col_one'})['col_one']` |\n| `rename(df, col_one = col1)[^2]` | `df.rename(columns = {'col1': 'col_one'})`            |\n| `mutate(df, c = a - b)`          | `df.assign(c = df['a'] - df['b'])`                    |\n\n[^2]: You can achieve the same result with `select()`. However, `rename()` can be helpful if you do not want to drop or add, or relocate columns.\n\n#### Sorting\n\n| R                                | pandas                                      |\n|----------------------------------|---------------------------------------------|\n| `arrange(df, col1, col2)`        | `df.sort_values(['col1', 'col2'])`          |\n| `arrange(df, desc(col1))[^3]`    | `df.sort_values('col1', ascending = False)` |\n\n[^3]: I personally prefer using `arrange(df, -col1)`\n\n#### Grouping and Summarising\n\n| R                                                                  | pandas                                      |\n|--------------------------------------------------------------------|---------------------------------------------|\n| `summary(df)`                                                      | `df.describe()`                             |\n| `group_by(df, col1)`                                               | `df.groupby('col1')`                        |\n| `group_by(df, col1) %>% summarise(avg = mean(col1, na.rm = TRUE))` | `df.groupby('col1').agg({'col1' : 'mean'})` |\n| `group_by(df, col1) %>% summarise(total = sum(col1))`              | `df.groupby('col1').sum()`                  |\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}